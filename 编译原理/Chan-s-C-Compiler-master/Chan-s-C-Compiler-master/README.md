# 编译原理 - C语言编译器(包括词法/语法分析器等)



## 项目结构如下


```
-source

--lexAnalysis		词法分析器(原创)
---analyse.c 		词法分析器
---text.c		 测试用例（被分析的C代码）

--lexSynAnalysis	语法分析器(转存)
---LexAnalysis.h	词法分析头文件
---SynAnalysis.h	语法分析头文件
---LexAnalysis.cpp	词法分析Cpp文件
---SynAnalysis.cpp	语法分析Cpp代码
---main.cpp     	主文件
---wenfa.txt		文法
---test.txt		测试用例（被分析的C代码）
```



## 词法分析器

[注:Sourse中lexAnalysis文件夹中为原创, 欢迎大家交流学习 ]

没有太多的时间精力, 故暂时中断.

...

看到一篇非常棒的语法分析器(来自于[niuox](http://my.csdn.net/niuox)大神),  故将其源码转存于此, 说明文档如下



## 语法分析器

[注: Source中lexSynAnalysis文件夹中的源码来自于[niuox](http://my.csdn.net/niuox)大神]

本程序实现一个分析C语言的词法分析+语法分析。

注意：

1.文法简略，没有实现的部分，可以在此文法的基础上进行扩充，本程序的采用自顶向下的LL(1)文法。

2.可以自动实现求First 集和 Follow 集。

3.处终结符外（有些硬编码的成分），终结符的文法可以自定义，也就是说读者可以自定义文法。

4.为方便理解，C语言的文法描述写成中文。

5.程序将词法分析和语法分析结合起来，词法分析的结果作为语法分析的输入。

6.最终结果在控制台显示的有：词法分析、First集、Follow集、Select集，在preciateResult.txt 中写入了语法分析结果，在preciateTable.txt 中写入了预测分析表。

7.文法的词素之间必须有空格分开。

项目结构如下：

![img](http://img.my.csdn.net/uploads/201211/23/1353647407_2507.jpg)

文法如下：

wenfa.txt:

```
<函数定义> -> <修饰词闭包> <类型> <变量> ( <参数声明> ) { <函数块> }  
<修饰词闭包> -> <修饰词> <修饰词闭包> | $  
<修饰词> -> describe  
<类型> -> type <取地址>  
<取地址> -> <星号闭包>  
<星号闭包> -> <星号> <星号闭包> | $  
<星号> -> *  
<变量> -> <标志符> <数组下标>  
<标志符> -> id 
<数组下标> -> [ <因式> ] | $  
<因式> -> ( <表达式> ) | <变量> | <数字>  
<数字> -> digit  
<表达式> -> <因子> <项>  
<因子> -> <因式> <因式递归>  
<因式递归> -> * <因式> <因式递归> | / <因式> <因式递归> | $  
<项> -> + <因子> <项> | - <因子> <项> | $  
<参数声明> -> <声明> <声明闭包> | $  
<声明> -> <修饰词闭包> <类型> <变量> <赋初值>  
<赋初值> -> = <右值> | $  
<右值> -> <表达式> | { <多个数据> }  
<多个数据> -> <数字> <数字闭包>  
<数字闭包> -> , <数字> <数字闭包> | $  
<声明闭包> -> , <声明> <声明闭包> | $  
<函数块> -> <声明语句闭包> <函数块闭包>  
<声明语句闭包> -> <声明语句> <声明语句闭包> | $  
<声明语句> -> <声明> ;  
<函数块闭包> -> <赋值函数> <函数块闭包> | <for循环> <函数块闭包> | <条件语句> <函数块闭包> | <函数返回> <函数块闭包> | $  
<赋值函数> -> <变量> <赋值或函数调用>  
<赋值或函数调用> -> = <右值> ; | ( <参数列表> ) ;  
<参数列表> -> <参数> <参数闭包>  
<参数闭包> -> , <参数> <参数闭包> | $  
<参数> -> <标志符> | <数字> | <字符串>  
<字符串> -> string  
<for循环> -> for ( <赋值函数> <逻辑表达式> ; <后缀表达式> ) { <函数块> }  
<逻辑表达式> -> <表达式> <逻辑运算符> <表达式>  
<逻辑运算符> -> < | > | == | !=  
<后缀表达式> -> <变量> <后缀运算符>  
<后缀运算符> -> ++ | --  
<条件语句> -> if ( <逻辑表达式> ) { <函数块> } <否则语句>  
<否则语句> -> else { <函数块> } | $  
<函数返回> -> return <因式> ;  
```



