### RMQ算法

---

RMQ算法，是一个快速求区间最值的离线算法，预处理时间复杂度$O（n*log(n)）$，查询$O(1)$，所以是一个很快速的算法。

当然这个问题用线段树同样能够解决，算法复杂度为：$O(N)~O(logN)$ 。

**RMQ：**

RMQ（Range Minimum/Maximum Query），即区间最值查询，是指这样一个问题：对于长度为n的数列A，

回答若干询问$RMQ（A,i,j）(i,j<=n)$，返回数列A中下标在$i，j$之间的最小/大值。

**分析：**

对于该问题，最容易想到的解决方案是遍历，复杂度是$O(n)$。但当数据量非常大且查询很频繁时，该算法无法在有效的时间内查询出正解。

本节介绍了一种比较高效的在线算法（ST算法）解决这个问题。所谓在线算法，是指用户每输入一个查询便马上处理一个查询。该算法一般用较长的时间做预处理，待信息充足以后便可以用较少的时间回答每个查询。ST（Sparse Table）算法是一个非常有名的在线处理RMQ问题的算法

 

**预处理：**

设$A[i]$是要求区间最值的数列，F[i, j]表示从第i个数起连续2^j个数中的最大值。（DP的状态）

例如：

A数列为：$3 2 4 5 6 8 1 2 9 7$

$F[1，0]$表示第1个数起，长度为$2^0=1$的最大值，其实就是3这个数。同理 $F[1,1] = max(3,2) = 3, F[1，2]=max(3,2,4,5) = 5，F[1，3] = max(3,2,4,5,6,8,1,2) = 8;$

并且我们可以容易的看出$F[i,0]$就等于$A[i]$。（DP的初始值）

这样，DP的状态、初值都已经有了，剩下的就是状态转移方程。

我们把$F[i，j]$平均分成两段（因为$F[i，j]$一定是偶数个数字），从 $i $到$i + 2 ^ {(j - 1)} - 1$为一段，$i + 2 ^ {(j - 1)}$到$i + 2 ^ {j} - 1$为一段

(长度都为$2 ^ {(j - 1)}$)。用上例说明，当$i=1，j=3$时就是$3,2,4,5 $和 $6,8,1,2$这两段。$F[i，j]$就是这两段各自最大值中的最大值。

于是我们得到了状态转移方程$F[i, j]=max（F[i，j-1], F[i + 2^{(j-1)}，j-1]）$。

[![img](https://images2015.cnblogs.com/blog/1024146/201706/1024146-20170606092032512-55210280.png)](https://images2015.cnblogs.com/blog/1024146/201706/1024146-20170606092032512-55210280.png)

```cpp
void RMQ(int num) //预处理->O(nlogn)
{
    for(int j = 1; j < 20; ++j)    // 这里j的范围根据具体题目数据定义
        for(int i = 1; i <= num; ++i)    // num为数组内整数的个数
            if(i + (1 << j) - 1 <= num)
            {
                maxsum[i][j] = max(maxsum[i][j - 1], maxsum[i + (1 << (j - 1))][j - 1]);
                minsum[i][j] = min(minsum[i][j - 1], minsum[i + (1 << (j - 1))][j - 1]);
            }
}
```

考虑一下 为什么j是外循环而i是内循环?

```
答案是不可以。因为我们需要理解这个状态转移方程的意义。
状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。
而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。
为了避免这样的错误，一定要好好理解这个状态转移方程所代表的含义。
```

 

**查询：**

假如我们需要查询的区间为$(i,j)$，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂

（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。

因为这个区间的长度为$j - i + 1$,所以我们可以取$k=log_2( j - i + 1)$，则有：$RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])$。

举例说明，要求区间$[2，8]$的最大值，$k = log_2（8 - 2 + 1）= 2$，即求$max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])$；

在这里我们也需要注意一个地方，就是<<运算符和+-运算符的优先级。

 

**实战一下：**

 

[poj 3264 Balanced Lineup](http://poj.org/problem?id=3264)

 

题目大意：

　　　　　输入一组整数，然后给定一下查询区间，输出查询区间内最大值与最小值的差值。

代码：

```cpp
 //#include<bits/stdc++.h>
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
const int maxn = 5e4 + 10;
int maxsum[maxn][20], minsum[maxn][20];
void RMQ(int num){
    for (int j = 1; (1<<j) <= num; j++){
        for (int i = 1; i+(1<<j)-1 <= num; i++){
            if(i+(1<<j)-1<=num){
                maxsum[i][j] = max(maxsum[i][j - 1], maxsum[i + (1 << (j - 1))][j - 1]);
                minsum[i][j] = min(minsum[i][j - 1], minsum[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
}
int n, q;
int main(){
    while(~scanf("%d%d", &n, &q)){
        //cin >> n >> q;
        for (int i = 1; i<=n; i++){
            int x;
            scanf("%d", &x);
            maxsum[i][0] = x;
            minsum[i][0] = x;
        }
        RMQ(n);
        while(q--){
            int x, y;
            scanf("%d%d", &x, &y);
            int z = 0;
            while((1<<(z+1)) <= y-x+1)
                z++;
            int ans = max(maxsum[x][z], maxsum[y - (1 << z) + 1][z]) - min(minsum[x][z], minsum[y - (1 << z) + 1][z]);
            printf("%d\n", ans);
        }
    }
    return 0;
}
```