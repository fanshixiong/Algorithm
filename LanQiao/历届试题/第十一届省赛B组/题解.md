





### 试题 A: 跑步训练

本题总分：5 分



#### 题目

【问题描述】

小明要做一个跑步训练。初始时，小明充满体力，体力值计为$ 10000$。如果小明跑步，每分钟损耗

$600 $的体力。如果小明休息，每分钟增加 $300$的体力。体力的损耗和增加都是均匀变化的。

小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 $0$，他就停止锻炼。

请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。



#### 思路

模拟就行



#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
	
	int S = 10000;
	int sun = 10, ad = 5;
	
	int t = 0, c = 0;
	bool flag = false;
	while(S > 0){
		if(!flag){
			S -= 10;
			t++;
			c++;
			if(c == 60){
				flag = !flag;
				c = 0;
			}
		}
		else{
			S += 5;
			t++;
			c++;
			if(c == 60) {
				flag = !flag;
				c = 0;
			}
		}
	}
	cout << t << endl;
	
	return 0;
}
```



>   答案：3880

 

 

### 试题 B: 纪念日

本题总分：5 分



#### 题目

【问题描述】

2020 年 7 月 1 日是A组织 成立 99 周年纪念日。 A组织成立于 1921 年 7 月 23 日。请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共包含多少分钟？

 

#### 思路

excel

 

![image-20201014171654022](F:\c++\Game\LanQiao\历届试题\第十一届省赛B组\题解.assets\image-20201014171654022.png)

 

 

>   答案：52038720

 

 

 

 

### 试题 C: 合并检测

本题总分：10 分



#### 题目

【问题描述】

\*\*\*（敏感字）由 \*\*\*（敏感字）引起，最近在 A 国蔓延，为了尽快控制 ***（敏感字），A 国准备给大量民众进病毒核酸检测。然而，用于检测的试剂盒紧缺。为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看，如果检测前$ k - 1 $个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k + 1 个试剂盒完成了 k 个人的检测。A 国估计被测的民众的感染率大概是 1%，呈均匀分布。请问 k 取多少能最节省试剂盒？

 



#### 思路

数学代换。

设总人数为$n$, 感染率是$p$,  每次$k$人，总试剂数$sum$。

求得：$sum = \lceil n/k \rceil + n *k* p$

求导得： $sum = n*(0.01*k^2-1)/k^2$

得： $k = 10$

>   答案： 10

 

 

 

### 试题 D: REPEAT 程序

本题总分：10 分



#### 题目

【问题描述】

附件 prog.txt 中是一个用某种语言写的程序。

其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，

从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。

例如如下片段：

REPEAT 2:

A = A + 4

REPEAT 5:

REPEAT 6:

A = A + 5

A = A + 7

A = A + 8

A = A + 9

![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200706231621107-1093550992.png)

 

 

 

该片段中从 A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的

循环两次中。

REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。

A = A + 5 实际总共的循环次数是 2

×

5

×

6 = 60 次。

请问该程序执行完毕之后，A 的值是多少？

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯B;

import java.util.Scanner;
//文件在  https://files.cnblogs.com/files/a1439775520/C大学B组.zip
public class REPEAT程序 {
    public static void main(String[] args) {
        int[] layer = new int[10000];
        int[] count = new int[10000];
        Scanner sc = new Scanner(System.in);
        int pointer = 0, result = 0, curCount = 1;
       sc.nextLine();
        layer[pointer] = -1; count[pointer] = 1;
        while (sc.hasNext()) {
            String ss = sc.nextLine();
            if (ss.equals("0")){
                break;
            }
            char[] s = ss.toCharArray();
            int n = s.length, p = 0;
            while (s[p] == ' ') p++; // 统计缩进
            // 判断是不是在一层，如果当前层数小于上一次的层数，循环的次数就要除上一次的循环数
            while (layer[pointer] >= p) curCount /= count[pointer--];
            if (s[n - 1] == ':') { // 当前行是循环
                //k为循环的次数
                int k = s[n - 2] - '0';
                //循环又往里走了一层
                pointer = pointer + 1;
                //w为循环次数
                curCount *= k;
                //a放的是当前层数是多少个空格
                //b放地是当前循环的次数
                layer[pointer] = p;count[pointer] = k;
            } else {
                //证明这个是A加值，k为A加的值
                int k = s[n - 1] - '0';
                //w是循环的次数
                result += k * curCount;
            }
        }
        System.out.println(result);
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

PS:

　　记得末尾我加了一个0结束循环

 ![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200707121356162-1693687860.png)

 

 

 

 

试题 E: 矩阵
本题总分：15 分

【问题描述】

把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，同一

列中下边的比上边的大。一共有多少种方案？

答案很大，你只需要给出方案数除以 2020 的余数即可。

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯B;

public class E矩阵1 {
    public static void main(String[] args) {
        int n = 2020;
        //dp[i][j]表示，从i个数选j个数
        int[][] dp = new int[3000][3000];
        dp[1][1] = 1; // 1必然放在第一行
        //只要保证第一行的数比第二行的数多就可以了，后面的数会越来越大，会符合小到大的规律
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] += dp[i - 1][j - 1]; // 放到第一层
                if (i - j <= j) {
                    //当进入if说明，i没有超过j的两倍了，
                    // （如果超过j的两倍，说明第一行肯定比第二行少了）
                    //本身就是取一半的数字，如果超过两倍，说明取不到一半，不能参与计算
                    dp[i][j] += dp[i - 1][j];   //放到第二层
                }
                dp[i][j] %= 2020;
            }
        }
        System.out.println(dp[n][n/2]);
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 

 ![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200707112418336-750977037.png)

 

 

 

试题 F: 整除序列
时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分

【问题描述】

有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输

出这个序列中值为正数的项。

【输入格式】

输入一行包含一个整数 n。

【输出格式】

输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。

【样例输入】

20

【样例输出】

20 10 5 2 1

【评测用例规模与约定】

对于 80% 的评测用例，1 ≤ n ≤ 10^9。

对于所有评测用例，1 ≤ n≤ 10^18。

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯;

import java.util.Scanner;

public class G整除序列 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.close();
        while (n != 0) {
            System.out.print(n + " ");
            n = n >> 1;//等价于/2，位运算相对快一些
        }
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200706165407842-1151369817.png)

 

 

 

试题 G: 解码
时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分

【问题描述】

小明有一串很长的英文字母，可能包含大写和小写。

在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字母表

达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。

例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写成 a4a、

aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表

达，小明不会将连续的超过 9 个相同的字符写成简写的形式。

现在给出简写后的字符串，请帮助小明还原成原来的串。

【输入格式】

输入一行包含一个字符串。

【输出格式】

输出一个字符串，表示还原后的串。

【样例输入】

H3el5o2

【样例输出】

HHHellllloo

【评测用例规模与约定】

对于所有评测用例，字符串由大小写英文字母和数字组成，长度不超过

100。

请注意原来的串长度可能超过 100。

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯B;

import java.util.Scanner;

public class G解码 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        sc.close();
        StringBuilder sb = new StringBuilder();
        char[] num = s.toCharArray();
        char temp='0';
        int count=0;
        int len = s.length();
        for (int i=0;i<len;i++){
            if(Character.isDigit(num[i])){
                count=num[i]-'0';
                for (int j=0;j<count;j++){
                    sb.append(temp);
                }
            } else{
                temp=num[i];
                if(i<len-1 && Character.isDigit(num[i+1])){
                    continue;
                } else {
                    sb.append(temp);
                }
            }
        }
        System.out.println(sb.toString());
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200706231823320-445409469.png)

 

 

 

 

 

试题 H: 走方格
时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分

【问题描述】

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，

从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。

现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下

走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

【输入格式】

输入一行包含两个整数 n, m。

【输出格式】

输出一个整数，表示答案。

【样例输入】

3 4

【样例输出】

2

【样例输入】

6 6

 

【样例输出】

0

【评测用例规模与约定】

对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯;

import java.util.Scanner;

public class H走方格 {
    public static void main(String[] args) {
        //输入矩阵的宽高
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        sc.close();
        int[][] dp = new int[n][m];
        dp[0][0]=1;
        //这个规律是只能往右下走，也就是只能取左上的值
        for (int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                //第一行一列无需处理
                 if(i==0 && j==0){
                     continue;
                 }
                 //只要不是第一行就可以取上面的
                 if(i>0){
                     dp[i][j]+=dp[i-1][j];
                 }
                 //只要不是第一列就可以取左面的
                 if(j>0){

                     dp[i][j]+=dp[i][j-1];
                 }
                 //如果是偶数行列不能取值，这里是奇数，因为我的是从0开始，所以偶数的就变成了奇数
                 if((i&1)==1 && (j&1)==1){
                     dp[i][j]=0;
                 }
            }
        }
        System.out.println(dp[n-1][m-1]);
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 

![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200706165439397-443882940.png)

 

 

 

试题 I: 整数拼接
时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分

【问题描述】

给定义个长度为 n 的数组 A1, A2, · · · , A**n。你可以从中选出两个数 A**i 和 A**j

(i 不等于 j)，然后将 A**i 和 A**j 一前一后拼成一个新的整数。例如 12 和 345 可

以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便

是 A**i = A**j 时。

请你计算有多少种拼法满足拼出的整数是 K 的倍数。

【输入格式】

第一行包含 2 个整数 n 和 K。

第二行包含 n 个整数 A1, A2, · · · , A**n。

【输出格式】

一个整数代表答案。

【样例输入】

4 2

1 2 3 4

【样例输出】

6

【评测用例规模与约定】

对于 30% 的评测用例，1 ≤ n≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10^4。

对于所有评测用例，1 ≤ n≤ 10^5，1 ≤ K≤ 105，1 ≤ Ai ≤ 10^9。

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯B;

import java.util.Scanner;

public class I整数拼接1 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] num = new int[n];
        int[][] a = new int[k][10];
        int[][] b = new int[k][10];
//int aa=1111111111;
        int temp=0;
        //记录有哪些数自己和自己拼接可以为k倍
        int subtract=0;
        for (int i=0;i<n;i++){
            num[i]=sc.nextInt();
            //取余
            temp=num[i]%k;
            //余数为temp的，并且位数为当前数字相同的
            ++b[temp][getLen(num[i])];
            //求这个数*这个数的位数
            for (int j =1;j<=9;j++){
                    //a[i][j]代表%k余数为i的，后面带10的j次方（因为后面的数不知道几位，所以要把1-9位都算一下）
                ++a[((temp*((int) (Math.pow(10,j))%k))%k)][j];
            }
            //如果自身可以拼接，就纪录一下，最后减去自身拼接的数
             if(temp+(temp*(getLen(num[i])%k))%k==k){
                 subtract++;
             }
        }
        int count=0;
        for (int i=0;i<k;i++){
            for (int j =1;j<=9;j++){
                //（余数为i的并且要加上位数为j的数字）的数量*（余数为（k-i）%k并且数字为j位数的）得数量就是组合拼接的数量
                count+=a[i][j]*b[(k-i)%k][j];
            }
        }
        System.out.println(count-subtract);
    }
    //求num有几位
    public static int getLen(int num){
        int len=1;
        while (num!=0){
            num/=10;
            len*=10;
        }
        return len/10;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 ![img](https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200707100815814-191118209.png)

 

 

 

 

试题 J: 网络分析
时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分

【问题描述】

小明正在做一个网络实验。

他设置了 n 台电脑，称为节点，用于收发和存储数据。

初始时，所有节点都是独立的，不存在任何连接。

小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信

了。两个节点如果存在网线连接，称为相邻。

小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送

到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接

或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。

一条信息只存储一次。

给出小明连接和测试的过程，请计算出每个节点存储信息的大小。

【输入格式】

输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节点从

1 至 n 编号。

接下来 m 行，每行三个整数，表示一个操作。

如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 a = b

时，表示连接了一个自环，对网络没有实质影响。

如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。

【输出格式】

输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示进行

完上述操作后节点 1 至节点 n 上存储信息的大小。

试题J: 网络分析 12第十一届蓝桥杯大赛软件类省赛 C/C++ 大学 B 组

【样例输入】

4 8

1 1 2

2 1 10

2 3 5

1 4 1

2 2 2

1 1 2

1 2 4

2 2 1

【样例输出】

13 13 5 3

【评测用例规模与约定】

对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。

对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。

对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。

对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package 第十一届蓝桥杯B;

import java.util.LinkedList;
import java.util.Scanner;

public class J网络分析1 {
    static int[] data ;
    static boolean[] bool ;
    static  LinkedList<LinkedList<Integer>> list = new  LinkedList<LinkedList<Integer>>();
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        data=new int[n+1];
        bool=new boolean[n+1];
        int a=0,b=0,c=0;
        for (int i =0;i<=n;i++){
            list.add(new LinkedList<>());
        }
        for (int i=0;i<m;i++){
            a=sc.nextInt();
            b=sc.nextInt();
            c=sc.nextInt();
            //网络题把他们互相联系起来
            if(a==1){
                list.get(b).add(c);
                list.get(c).add(b);
            } else{

                bool=new boolean[n+1];
                dfs(b,c);
            }
        }
        for (int i=1;i<=n;i++){
            System.out.println(data[i]);
        }
    }
//dfs遍历每一个结点
    public static void dfs(int node,int num){
        bool[node]=true;
        data[node]+=num;
        LinkedList<Integer> templist=list.get(node);
        for(int i:templist){
            if(!bool[i]){

                dfs(i,num);

            }
        }
    }


}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)