# 蓝桥杯复习提纲

## 算法

### 枚举



### 排序



### 搜索



### 计数



### 贪心

#### 区间调度

##### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20201004200801104](F:\c++\Game\LanQiao\复习.assets\image-20201004200801104.png)

代码：

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.size() == 0) return 0;
        
        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) -> bool {
            return a[1] < b[1];
        });
        
        int end = intervals[0][1];
        int res = -1;
        for(auto G:intervals){
            if(G[0] < end) res++;
            else end = G[1];
        }
        return res;
    }
};
```



### 动态规划



![image-20201002105136332](F:\c++\Game\LanQiao\复习.assets\image-20201002105136332.png)

#### 背包系列

###### 思路：

```cpp
for (int i = 1; i <= n; i++) {
    // 01背包：逆序遍历
	// for (int j = m; j >= w[i]; j--) {
	// 完全背包：正向遍历
	for (int j = w[i]; j <= m; j++) {
		maxValue[j] = max(maxValue[j], maxValue[j - w[i]] + v[i]);
    }
}
```



##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

01背包(内外层循环的顺序)

```cpp
class Solution {
public:
    int subsets(vector<int>& nums, int target){
        vector<int> dp(target+10, 0);
        dp[0] = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = target; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] += dp[j-nums[i]];
                else dp[j] = dp[j];
            }
        }
        return dp[target];
    }
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for(int num : nums) sum += num;
        // 2 * A = S + sum(nums) A是正数集合 B是负数集合
        if(sum < S || (sum+S)%2 == 1) return 0;
        return subsets(nums, (sum+S)/2);
    }
};
```

##### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int &num : nums) sum += num;
        if(sum % 2 == 1) return false;
        sum /= 2;
        vector<bool> dp(sum+1, 0);
        dp[0] = true;
        for(int i = 0; i < nums.size(); i++){
            for(int j = sum; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] = dp[j] || dp[j-nums[]];
            }
        }
        return dp[sum];
    }
};
```



##### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+10, 0x3f3f3f3f);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(auto &coin : coins)
                if(i - coin >= 0) dp[i] = min(dp[i], dp[i-coin]+1);
        }
        return dp[amount] == 0x3f3f3f3f ? -1 : dp[amount];
    }
};
```





#### 股票系列：

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

思路：

```cpp
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```

状态转移方程：

```cpp
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

代码：

```cpp
class Solution {
public:
    int maxProfit_inf(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<vector<int> > dp(prices.size() + 2, vector<int>(2, 0));
        dp[0][0] = 0; dp[0][1] = -prices[0];
        for(int i = 1; i <= prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i-1]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1]);
        }
        return dp[prices.size()][0];
    }

    int maxProfit(int K, vector<int>& prices) {
        if(!prices.size()) return 0;
        if(K >= prices.size()/2) return maxProfit_inf(prices);

        vector<vector<vector<int> > > dp(prices.size() + 2, vector<vector<int> >(K+1, vector<int>(2, 0)));
        for(int i = 0; i <= K; i++){
            dp[0][i][0] = 0; dp[0][i][1] = -0x3f3f3f3f;
        }

        for(int i = 1; i <= prices.size(); i++){
            for(int k = 1; k <= K; k++){
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i-1]);
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1]);
            }
        }
        return dp[prices.size()][K][0];
    }
};
```

#### 打家劫舍系列

##### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

思路：

```cpp
dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
           选上一个， 或者选当前和上上一个
```



代码：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size()+2, 0);
        for(int i = nums.size()-1; i>=0; i--){
            dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
        }
        return dp[0];
    }
};
```



#### 字符串DP

##### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

KMP / DP

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



##### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```cpp
int dp[1000][1000];
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i <= m; i++) dp[i][0] = i;
        for(int j = 0; j <= n; j++) dp[0][j] = j;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
            }
        }
        return dp[m][n];
    }
};
```



##### [651.四键键盘](https://leetcode-cn.com/problems/4-keys-keyboard)

![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6413dee2c83f74205c7f2d5eb0784232429512de.png?alt=media)



![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F43c7985b4e7201e0ffc8ff5c580883e60e98ed3b.jpg?alt=media)

代码：

```java
public int maxA(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        // 按 A 键
        dp[i] = dp[i - 1] + 1;
        for (int j = 2; j < i; j++) {
            // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }
    // N 次按键之后最多有几个 A？
    return dp[N];
}
```



##### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > dp(s.size(), vector<bool>(s.size(), false));

        for(int i = 0; i < s.size(); i++) dp[i][i] = true;

        int begin = 0, maxSize = 1;
        for(int j = 1; j < s.size(); j++){
            for(int i = 0; i < j; i++){
                if(s[i] == s[j]){
                    if(j - i < 3) dp[i][j] = true;
                    else dp[i][j] = dp[i+1][j-1];
                    
                }
                else dp[i][j] = false;

                if(dp[i][j] && maxSize < j-i+1){
                    maxSize = j-i+1;
                    begin = i;
                }
            }
        }

        return s.substr(begin, maxSize);
    }
};
```



##### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

代码：

```cpp
int dp[1010];
class Solution {
public:
    // int longestPalindromeSubseq(string s) {
    //     vector<vector<int> > dp(s.size()+10, vector<int>(s.size()+10, 0));
    //     for(int i = 0; i < s.size(); i++) dp[i][i] = 1;

    //     for(int i = s.size()-2; i >= 0; i--){
    //         for(int j = i+1; j < s.size(); j++){
    //             if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2;
    //             else dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
    //         }
    //     }
    //     return dp[0][s.size()-1];
    // }
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        for(int i = 0; i < n; i++) dp[i] = 1;

        for(int i = n-2; i >= 0; i--){
            int pre = 0;
            for(int j = i+1; j < n; j++){
                int t = dp[j];
                if(s[i] == s[j]) dp[j] = pre + 2;
                else dp[j] = max(dp[j-1], dp[j]);
                pre = t;
            }
        }
        return dp[s.size()-1];
    }
};
```



#### 博弈

##### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int> > dp(n+1, vector<int>(n+1, 0));
        // dp[i][j] 定义：区间 piles[i..j] 内先手可以获得的净胜分
        for(int i = 0; i < n; i++) dp[i][i] = piles[i];
        for(int i = n-2; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]);
            }
        }
        return dp[0][n-1] > 0;
    }
};
```



#### 区间DP

##### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> points(n+2);
        for(int i = 1; i <= n; i++) points[i] = nums[i-1];
        points[0] = points[n+1] = 1;
        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));

        for(int i = n; i >= 0; i--){
            for(int j = i+1; j <= n + 1; j++){
                for(int k = i+1; k < j; k++){
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i]*points[k]*points[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```





#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), -0x3f3f);
        int res = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(nums[i], nums[i] + dp[i-1]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```



#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = i-1; j>=0; j--){
                if(nums[j] < nums[i]) dp[i] = max(dp[i], dp[j]+1);
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```cpp
int dp[1010];
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();

        //vector<vector<int> > dp(m+1, vector<int>(n+1, 0));
        for(int i = 0; i <= n; i++) dp[i] = 0;

        // for(int i = 1; i <= m; i++){
        //     for(int j = 1; j <= n; j++){
        //         if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
        //         else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        //     }
        // }
        
        for(int i = 1; i <= m; i++){
            int pre = 0;
            for(int j = 1; j <= n; j++){
                int t = dp[j];
                if(text1[i-1] == text2[j-1]) dp[j] = pre + 1;
                else dp[j] = max(dp[j], dp[j-1]);
                pre = t;
            }
        }
        return dp[n];
    }
};
```





### 数论



### 图论



### 字符串

>    处理空格 用`stringstream`.

#### 回文串



#### 字典树

模板：

```cpp
class Trie {
private:
    bool isWord = false;
    Trie* next[26] = {nullptr};
public:
    /** Initialize your data structure here. */
    Trie() {

    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) root->next[c-'a'] = new Trie();
            root = root->next[c-'a'];
        }
        root->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return root->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* root = this;
        for(auto c : prefix){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return true;
    }
};
```



#### KMP

```cpp
void getNext(string s, vector<int> &next){
    int i=0, j=-1;
    next[0] = -1;
    while(i < s.size()){
        if(j == -1 || s[i] == s[j]){
            i++; j++;
            next[i] = j;
        }
        else j = next[j];
    }
}
int kmp(string s, string pattern){
    int i = 0, j = 0;
    vector<int> next(pattern.size());
    getNext(pattern, next);
    
    while(i < s.size() && j < (int)pattern.size()){
        if(j == -1 || s[i] == pattern[j]){
            i++; j++;
        }
        else j = next[j];
    }
    //匹配完成
    if(j >= pattern.size()) return i-j;
    else return -1;
}
```

DP:

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



#### Manacher

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size < 2) {
            return s;
        }

        // 得到预处理字符串
        string str = "#";
        for (int i = 0; i < s.size(); ++i) {
            str += s[i];
            str += "#";
        }
        // 新字符串的长度
        int strSize = 2 * size + 1;
        // 数组 p 记录了扫描过的回文子串的信息
        vector<int> p(strSize, 0);

        // 双指针，它们是一一对应的，须同时更新
        int maxRight = 0;
        int center = 0;

        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度
        int maxLen = 1;
        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新
        int start = 0;

        for (int i = 0; i < strSize; ++i) {
            if (i < maxRight) {
                int mirror = (2 * center) - i;
                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解
                p[i] = min(maxRight - i, p[mirror]);
            }

            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中
            int left = i - (1 + p[i]);
            int right = i + (1 + p[i]);

            // left >= 0 && right < sLen 保证不越界
            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次
            while (left >= 0 && right < strSize && str[left] == str[right]) {
                p[i]++;
                left--;
                right++;

            }

            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者
            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了
            if (i + p[i] > maxRight) {
                // maxRight 和 center 需要同时更新
                maxRight = i + p[i];
                center = i;
            }
            if (p[i] > maxLen) {
                // 记录最长回文子串的长度和相应它在原始字符串中的起点
                maxLen = p[i];
                start = (i - maxLen) / 2;
            }
        }
        return s.substr(start, maxLen);
    }
};
```



## 数据结构

### 图



### 堆



### 树

二叉树 Morris遍历  前序中序后续遍历

根据前序遍历和中序遍历。。。。。



### 栈



### 队列



### 字符串



### 数组



### 线段树

