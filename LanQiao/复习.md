# 蓝桥杯复习提纲

## 算法

### 枚举



### 排序



### 搜索



### 回溯



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```cpp
do{
    
} while(next_permutation(nums.begin(), nums.end()))
```



```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        do {
            result.emplace_back(nums);
        } while (next_permutation(nums.begin(), nums.end()));
        return result;
    }
};
```



#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```cpp
// 二维
class Solution {
public:
    vector<vector<string> > ans;
    int n;
    bool check(vector<string> &queen, int row, int col){
        for(int i=0; i<row; i++){
            if(queen[i][col] == 'Q') return false;
        }
        for(int i=row-1, j=col-1; i>=0 && j>=0; j--, i--){
            if(queen[i][j]=='Q') return false;
        }
        for(int i=row-1, j=col+1; i>=0 && j<n; j++, i--){
            if(queen[i][j] == 'Q') return false;
        }
        return true;
    }
    void helper(vector<string> &queen, int row){
        if(row == n){
            ans.emplace_back(queen);
            return;
        }
        for(int i=0; i<n; i++){
            if(check(queen, row, i)){
                queen[row][i] = 'Q';
                helper(queen, row+1);
                queen[row][i] = '.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        vector<string> queen(n, string(n, '.'));
        helper(queen, 0);
        return ans;
    }
};
```



```cpp
// 一维

class Solution {
public:
    vector<vector<string> > ans;
    int n;
    bool check(vector<int> &queen, int row, int col){
        for(int i=0; i<row; i++){
            if(queen[i]==col || abs(queen[i]-col) == abs(i-row)) return false;
        }
        return true;
    }
    void helper(vector<int> &queen, int row){
        if(row == n){
            vector<string> tmp(n, string(n, '.'));
            for(int i=0; i<n; i++){
                tmp[i][queen[i]] = 'Q';
            }
            ans.emplace_back(tmp);
            return;
        }
        for(int i=0; i<n; i++){
            if(check(queen, row, i)){
                queen[row]=i;
                helper(queen, row+1);
                queen[row]=-1;
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        vector<int> queen(n, -1);
        helper(queen, 0);
        return ans;
    }
};

```



#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

```cpp
bitset:
状态压缩
1. 使用 bitset<9> 来压缩存储每一行、每一列、每一个 3x3 宫格中 1-9 是否出现
2. 这样每一个格子就可以计算出所有不能填的数字，然后得到所有能填的数字 getPossibleStatus()
3. 填入数字和回溯时，只需要更新存储信息
4. 每个格子在使用时，会根据存储信息重新计算能填的数字

回溯
1. 每次都使用 getNext() 选择能填的数字最少的格子开始填，这样填错的概率最小，回溯次数也会变少
2. 使用 fillNum() 在填入和回溯时负责更新存储信息
3. 一旦全部填写成功，一路返回 true ，结束递归
```

![图片.png](https://pic.leetcode-cn.com/1fb1c64cfddb5c66b61bd769224724a05027172d6486feb19b3a16d9473372ee-%E5%9B%BE%E7%89%87.png)

```cpp
class Solution {
public:
    vector<bitset<9> > rows, cols;
    vector<vector<bitset<9> > > cells;

    bitset<9> getPosibleStatus(int x, int y){
        return ~(rows[x] | cols[y] | cells[x/3][y/3]);
    }

    vector<int> getNext(vector<vector<char> > &board){
        
        vector<int> ans;
        int minCnt = 0x3f;
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[i].size(); j++){
                if(board[i][j] != '.') continue;
                auto cur = getPosibleStatus(i, j);
                int c = cur.count();
                if(c < minCnt){
                    minCnt = c;
                    ans = {i, j};
                }
            }
        }

        return ans;
    }
    void fillNum(int x, int y, int n, bool flag){
        rows[x][n] = flag ? 1 : 0;
        cols[y][n] = flag ? 1 : 0;
        cells[x/3][y/3][n] = flag ? 1 : 0;
    }

    bool helper(vector<vector<char> > &board, int cnt){
        if(cnt == 0) return true;

        auto next = getNext(board);
        auto bits = getPosibleStatus(next[0], next[1]);

        for(int i=0; i<bits.size(); i++){
            if(!bits.test(i)) continue;
            int x = next[0], y = next[1];
            fillNum(x, y, i, true);
            board[x][y] = i+'1';
            if(helper(board, cnt-1)) return true;
            board[x][y] = '.';
            fillNum(x, y, i, false);
        }

        return false;
    }
    void solveSudoku(vector<vector<char>>& board) {
        rows = vector<bitset<9> > (9, bitset<9>());
        cols = vector<bitset<9> > (9, bitset<9>());
        cells = vector<vector<bitset<9> > > (3, vector<bitset<9> >(3, bitset<9>()));


        int cnt = 0;
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[i].size(); j++){
                cnt += (board[i][j] == '.');
                if(board[i][j] == '.') continue;
            
                int n=board[i][j] - '1';
                rows[i] |= (1<<n);
                cols[j] |= (1<<n);
                cells[i/3][j/3] |= (1<<n);
            }
        }

        helper(board, cnt);
    }
};
```

#### [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

```cpp
class Solution {
public:
    int m, n;
    int dist[8][2] = {1, 0, -1, 0, 0, 1, 0, -1, 1, -1, -1, 1, 1, 1, -1, -1};
    void bfs(vector<vector<char>>& board, int sr, int sc){
        queue<pair<int, int> > q;
        bool vis[55][55];
        memset(vis, false, sizeof vis);
        vis[sr][sc] = true;
        q.push({sr, sc});
        while(!q.empty()){
            auto u = q.front(); q.pop();
            int x=u.first, y=u.second;
            int cnt=0;
            for(int i=0; i<8; i++){
                int x1=x+dist[i][0];
                int y1=y+dist[i][1];
                if(x1<0||y1<0||x1>=m||y1>=n) continue;
                cnt += board[x1][y1] == 'M';
            }

            if(cnt){
                board[x][y] = cnt+'0';
            }else{                
                board[x][y] = 'B';

                for(int i=0; i<8; i++){
                    int x1=x+dist[i][0];
                    int y1=y+dist[i][1];
                    if(x1<0||y1<0||x1>=m||y1>=n || vis[x1][y1] || board[x1][y1]!='E') continue;
                    q.push({x1, y1});
                    vis[x1][y1] = true;
                }
            }
        }
    }
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        m=board.size(); n=board[0].size();
        if(board[click[0]][click[1]] == 'M'){
            board[click[0]][click[1]] = 'X';
        }else{
            bfs(board, click[0], click[1]);
        }
        return board;
    }
};
```



#### [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)

```cpp
class Solution {
public: 
    static constexpr int TARGET = 24;
    static constexpr double EPSILON = 1e-6;
    static constexpr int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;
    bool judgePoint24(vector<int>& nums) {
        vector<double> ans;
        for(int num : nums) ans.emplace_back(static_cast<double>(num));
        return helper(ans);
    }

    bool helper(vector<double> nums){
        if(nums.size() == 0) return false;
        if(nums.size() == 1) return fabs(TARGET-nums[0])<=EPSILON;
        
        int sz = nums.size();

        for(int i=0; i<sz; i++){
            for(int j=0; j<sz; j++){
                if(i==j) continue;
                vector<double> l;
                for(int k=0; k<sz; k++){
                    if(k==j || k==i) continue;
                    l.emplace_back(nums[k]);
                }

                for (int k = 0; k < 4; k++) {
                    /* 
                    加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，
                    则对于选出的 22 个数字不需要考虑不同的顺序，
                    在遇到第二种顺序时可以不进行运算，直接跳过。
                    */
                    if (k < 2 && i > j)  continue; 
                    if (k == ADD) l.emplace_back(nums[i] + nums[j]);
                    else if (k == MULTIPLY) l.emplace_back(nums[i] * nums[j]);
                    else if (k == SUBTRACT) l.emplace_back(nums[i] - nums[j]);
                    else if (k == DIVIDE) {
                        // 除法为零
                        if (fabs(nums[j]) < EPSILON) continue;
                        l.emplace_back(nums[i] / nums[j]);
                    }
                    if (helper(l)) return true; 
                    l.pop_back();
                }
            }
        }
        return false;
    }
};
```

#### [488. 祖玛游戏](https://leetcode-cn.com/problems/zuma-game/)

```cpp
1. 如果后面的球与前面的球颜色不一样，在这里尝试插入一个后面颜色的球
2. 如果相邻的两个球颜色相同，考虑在中间插入一个其他颜色的球，将他们分割
```

代码：

```cpp
class Solution {
public:
    int findMinStep(string board, string hand) {
        cnt = hand.size();
        for (auto c : hand) {
            h[c - 'A']++;
        }

        dfs(board, 0);
        return ans == INT_MAX ? -1 : ans;
    }

    void dfs(string board, int step) {
        shoot(board);

        if (board.empty()) {
            ans = min(ans, step);
        }
        if (step == cnt) return;
        if (step >= ans) return;

        set<pair<int, char>> ins;
        for (int i = 0; i < board.size(); i++) {
            int t = board[i] - 'A';
            if (i == 0 || board[i] != board[i - 1]) {
                if (h[t] != 0) {
                    ins.insert({ i, 'A' + t });
                }
            }
            if (i != 0 && board[i] == board[i - 1]) {
                for (int j = 0; j < h.size(); j++) {
                    if (j == t || h[j] == 0) continue;
                    ins.insert({ i, 'A' + j });
                }
            }
        }

        for (auto[i, c] : ins) {
            h[c - 'A']--;
            board.insert(i, 1, c);
            dfs(board, step + 1);
            board.erase(i, 1);
            h[c - 'A']++;
        }
    }

    void shoot(string& board) {
        for (int i = 0; i < (int)board.size() - 2; i++) {
            int j = i + 1;
            while (j < board.size() && board[i] == board[j]) j++;
            if (j - i < 3) {
                i = j - 1;
                continue;
            }
            board.erase(i, j - i);
            shoot(board);
            break;
        }
    }

private:
    int ans = INT_MAX;
    int cnt = 0;
    vector<int> h = vector<int>(26, 0);
};

```





### 计数

#### 进制转换

```cpp
void dec2bin(int num){
    stack<int> bin;
    while(num!=0){
        bin.push(num % 2);
        num /= 2;
    }
    return bin;
}
```



#### 卡特兰数

```cpp
int n, f[19]={1,1};
cin >> n;
for( int i=2;i<=n;++i ){
    for( int j=0;j<i;++j ){
        f[i] += f[j]*f[i-j-1];
    }
}
```





### 贪心

#### 区间调度

##### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20201004200801104](F:\c++\Game\LanQiao\复习.assets\image-20201004200801104.png)

代码：

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.size() == 0) return 0;
        
        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) -> bool {
            return a[1] < b[1];
        });
        
        int end = intervals[0][1];
        int res = -1;
        for(auto G:intervals){
            if(G[0] < end) res++;
            else end = G[1];
        }
        return res;
    }
};
```



### 动态规划



![image-20201002105136332](F:\c++\Game\LanQiao\复习.assets\image-20201002105136332.png)

#### 背包系列

###### 思路：

```cpp
for (int i = 1; i <= n; i++) {
    // 01背包：逆序遍历
	// for (int j = m; j >= w[i]; j--) {
	// 完全背包：正向遍历
	for (int j = w[i]; j <= m; j++) {
		maxValue[j] = max(maxValue[j], maxValue[j - w[i]] + v[i]);
    }
}
```



##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

01背包(内外层循环的顺序)

```cpp
class Solution {
public:
    int subsets(vector<int>& nums, int target){
        vector<int> dp(target+10, 0);
        dp[0] = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = target; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] += dp[j-nums[i]];
                else dp[j] = dp[j];
            }
        }
        return dp[target];
    }
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for(int num : nums) sum += num;
        // 2 * A = S + sum(nums) A是正数集合 B是负数集合
        if(sum < S || (sum+S)%2 == 1) return 0;
        return subsets(nums, (sum+S)/2);
    }
};
```

##### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int &num : nums) sum += num;
        if(sum % 2 == 1) return false;
        sum /= 2;
        vector<bool> dp(sum+1, 0);
        dp[0] = true;
        for(int i = 0; i < nums.size(); i++){
            for(int j = sum; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] = dp[j] || dp[j-nums[]];
            }
        }
        return dp[sum];
    }
};
```



##### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+10, 0x3f3f3f3f);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(auto &coin : coins)
                if(i - coin >= 0) dp[i] = min(dp[i], dp[i-coin]+1);
        }
        return dp[amount] == 0x3f3f3f3f ? -1 : dp[amount];
    }
};
```





#### 股票系列：

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

思路：

```cpp
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```

状态转移方程：

```cpp
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

代码：

```cpp
class Solution {
public:
    int maxProfit_inf(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<vector<int> > dp(prices.size() + 2, vector<int>(2, 0));
        dp[0][0] = 0; dp[0][1] = -prices[0];
        for(int i = 1; i <= prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i-1]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1]);
        }
        return dp[prices.size()][0];
    }

    int maxProfit(int K, vector<int>& prices) {
        if(!prices.size()) return 0;
        if(K >= prices.size()/2) return maxProfit_inf(prices);

        vector<vector<vector<int> > > dp(prices.size() + 2, vector<vector<int> >(K+1, vector<int>(2, 0)));
        for(int i = 0; i <= K; i++){
            dp[0][i][0] = 0; dp[0][i][1] = -0x3f3f3f3f;
        }

        for(int i = 1; i <= prices.size(); i++){
            for(int k = 1; k <= K; k++){
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i-1]);
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1]);
            }
        }
        return dp[prices.size()][K][0];
    }
};
```

#### 打家劫舍系列

##### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

思路：

```cpp
dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
           选上一个， 或者选当前和上上一个
```



代码：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size()+2, 0);
        for(int i = nums.size()-1; i>=0; i--){
            dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
        }
        return dp[0];
    }
};
```



#### 字符串DP

##### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

KMP / DP

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



##### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```cpp
int dp[1000][1000];
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i <= m; i++) dp[i][0] = i;
        for(int j = 0; j <= n; j++) dp[0][j] = j;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
            }
        }
        return dp[m][n];
    }
};
```



##### [651.四键键盘](https://leetcode-cn.com/problems/4-keys-keyboard)

![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6413dee2c83f74205c7f2d5eb0784232429512de.png?alt=media)



![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F43c7985b4e7201e0ffc8ff5c580883e60e98ed3b.jpg?alt=media)

代码：

```java
public int maxA(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        // 按 A 键
        dp[i] = dp[i - 1] + 1;
        for (int j = 2; j < i; j++) {
            // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }
    // N 次按键之后最多有几个 A？
    return dp[N];
}
```



##### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > dp(s.size(), vector<bool>(s.size(), false));

        for(int i = 0; i < s.size(); i++) dp[i][i] = true;

        int begin = 0, maxSize = 1;
        for(int j = 1; j < s.size(); j++){
            for(int i = 0; i < j; i++){
                if(s[i] == s[j]){
                    if(j - i < 3) dp[i][j] = true;
                    else dp[i][j] = dp[i+1][j-1];
                    
                }
                else dp[i][j] = false;

                if(dp[i][j] && maxSize < j-i+1){
                    maxSize = j-i+1;
                    begin = i;
                }
            }
        }

        return s.substr(begin, maxSize);
    }
};
```



##### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

代码：

```cpp
int dp[1010];
class Solution {
public:
    // int longestPalindromeSubseq(string s) {
    //     vector<vector<int> > dp(s.size()+10, vector<int>(s.size()+10, 0));
    //     for(int i = 0; i < s.size(); i++) dp[i][i] = 1;

    //     for(int i = s.size()-2; i >= 0; i--){
    //         for(int j = i+1; j < s.size(); j++){
    //             if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2;
    //             else dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
    //         }
    //     }
    //     return dp[0][s.size()-1];
    // }
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        for(int i = 0; i < n; i++) dp[i] = 1;

        for(int i = n-2; i >= 0; i--){
            int pre = 0;
            for(int j = i+1; j < n; j++){
                int t = dp[j];
                if(s[i] == s[j]) dp[j] = pre + 2;
                else dp[j] = max(dp[j-1], dp[j]);
                pre = t;
            }
        }
        return dp[s.size()-1];
    }
};
```



#### 博弈

##### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int> > dp(n+1, vector<int>(n+1, 0));
        // dp[i][j] 定义：区间 piles[i..j] 内先手可以获得的净胜分
        for(int i = 0; i < n; i++) dp[i][i] = piles[i];
        for(int i = n-2; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]);
            }
        }
        return dp[0][n-1] > 0;
    }
};
```



#### 区间DP

##### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> points(n+2);
        for(int i = 1; i <= n; i++) points[i] = nums[i-1];
        points[0] = points[n+1] = 1;
        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));

        for(int i = n; i >= 0; i--){
            for(int j = i+1; j <= n + 1; j++){
                for(int k = i+1; k < j; k++){
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i]*points[k]*points[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```



#### 树状DP

##### [834. 树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)

```cpp
class Solution {
public:
    vector<vector<int> > G;
    vector<int> ans;
    vector<int> dp, sz;
    void dfs(int u, int fa){
        dp[u] = 0;
        sz[u] = 1;
        for(auto v : G[u]){
            if(v == fa) continue;
            dfs(v, u);
            dp[u] += dp[v] + sz[v];
            sz[u] += sz[v];
        }
    }

    void dfs2(int u, int fa){
        ans[u] = dp[u];
        for(auto v : G[u]){
            if(v == fa) continue;
            int pu = dp[u], pv = dp[v];
            int su = sz[u], sv = sz[v];

            dp[u] -= dp[v] + sz[v];
            sz[u] -= sz[v];

            dp[v] += dp[u] + sz[u];
            sz[v] += sz[u];

            dfs2(v, u);

            dp[u] = pu; dp[v] = pv;
            sz[u] = su; sz[v] = sv;
        }
    }
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {
        G = vector<vector<int> > (N);
        ans = vector<int>(N);
        dp = vector<int>(N, 0);
        sz = vector<int>(N, 0);
        for(auto e : edges){
            G[e[0]].emplace_back(e[1]);
            G[e[1]].emplace_back(e[0]);
        }
        dfs(0, -1);
        // for(auto v : dp) cout << v << " ";
        dfs2(0, -1);
        return ans;
    }
};
```



#### 状压DP

##### [1349. 参加考试的最大学生数](https://leetcode-cn.com/problems/maximum-students-taking-exam/)

```cpp
int dp[10][1<<8];

//dp[i][bits] 表示前i行中，第i行作为情况为bits的最大答案
//bits 011011011 1：有人座， 0：无人座
class Solution {
public:
    int lowbit(int x){
        return x&-x;
    }
    int getcount(int x){
        int res=0;
        while(x>0){
            ++res;
            x-=lowbit(x);
        }
        return res;
    }
    int maxStudents(vector<vector<char>>& seats) {
        int n=seats.size(), m=seats[0].size();
        
        memset(dp, -1, sizeof(dp));
        dp[0][0] = 0;
        
        int lim = (1<<m);
        for(int i=1; i<=n; i++){
            for(int cur=0; cur<lim ;cur++){
                for(int pre = 0; pre < lim; pre++){
                    
                    if(dp[i-1][pre] == -1)
                        continue;
                    
                    bool flg=0;
                    for(int j=0; j<m; j++){
                        if(((cur>>j)&1) == 0) continue;
                        if(seats[i-1][j] == '#') flg=1;
                        if(j>=1 && ((cur>>(j-1))&1)) flg=1;
                        if(j<m-1 && ((cur>>(j+1))&1)) flg=1;
                        if(j >= 1 && ((pre>>(j-1))&1)) flg=1;
                        if(j<m-1 && ((pre >> (j+1))&1)) flg=1;
                    }
                    if(flg){
                        continue;
                    }
                    dp[i][cur] = max(dp[i][cur], dp[i-1][pre] + getcount(cur));
                }
            }
        }
        
        int ans=0;
        for(int i=0; i<lim; i++)
            ans = max(ans, dp[n][i]);
        return ans;
    }
};
```





##### [968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    /* 状态转移：
    a：root必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。
    b：覆盖整棵树需要的摄像头数目，无论 root 是否放置摄像头。
    c：覆盖两棵子树需要的摄像头数目，无论节点 root 本身是否被监控到。
    */

    vector<int> dfs(TreeNode* root){
        if(!root) return {INT_MAX/2, 0, 0};
        auto l = dfs(root->left);
        auto r = dfs(root->right);
        int a = l[2] + r[2] + 1;
        int b = min(a, min(l[1]+r[0], l[0]+r[1]));
        int c = min(a, l[1]+r[1]);
        // cout << a << " " << b << " " << c << endl;
        return {a, b, c};
    }
    int minCameraCover(TreeNode* root) {
        if(!root) return 0;
        auto ans = dfs(root);
        return ans[1];
    }
};
```





#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), -0x3f3f);
        int res = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(nums[i], nums[i] + dp[i-1]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```



#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = i-1; j>=0; j--){
                if(nums[j] < nums[i]) dp[i] = max(dp[i], dp[j]+1);
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```cpp
int dp[1010];
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();

        //vector<vector<int> > dp(m+1, vector<int>(n+1, 0));
        for(int i = 0; i <= n; i++) dp[i] = 0;

        // for(int i = 1; i <= m; i++){
        //     for(int j = 1; j <= n; j++){
        //         if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
        //         else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        //     }
        // }
        
        for(int i = 1; i <= m; i++){
            int pre = 0;
            for(int j = 1; j <= n; j++){
                int t = dp[j];
                if(text1[i-1] == text2[j-1]) dp[j] = pre + 1;
                else dp[j] = max(dp[j], dp[j-1]);
                pre = t;
            }
        }
        return dp[n];
    }
};
```



#### [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

```cpp
const int maxn = 1e5+10;
int dp[maxn][2];
class Solution {
public:
    int getMaxLen(vector<int>& nums) {
        memset(dp, 0, sizeof dp);
        int ans = 0;
        for(int i=1; i<=nums.size(); i++){
            if(nums[i-1] > 0){
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = dp[i-1][1] ? dp[i-1][1]+1 : 0;
            }
            if(nums[i-1] < 0){
                dp[i][0] = dp[i-1][1] ? dp[i-1][1]+1 : 0;
                dp[i][1] = dp[i-1][0] + 1;
            }
            //cout << dp[i][0] << " " << dp[i][1] << endl;
            ans = max(ans, dp[i][0]);
        }
        return ans;
    }
};
```



### 数论

#### 博弈

Nim

#### 排列组合

#### 数论

##### 	LCM / GCD

```cpp
int gcd(int a, int b) {
	return b ? gcd(b , a % b) : a;
}

int lcm(int a, int b) {
	return a / gcd(a, b) * b;
}
```



##### BigNum





##### 扩展欧几里得

`定理：`对于不完全为 0 的非负整数 $a$，$b$，$gcd（a，b）$表示$ a$，$b$ 的最大公约数，必然存在整数对 $x$，$y$ ，使得 $gcd（a，b）=a*x+b*y$。



```cpp
int e_gcd(int a, int b, int &x, int &y){
	if(!b){
		x=1; y=0;
		return a;
	}
	int gcd = e_gcd(b, a % b, y, x);
	y -= a / b * x;
	return gcd;
}
```



##### 素数筛

```cpp
void get_prime(vector<int> &prime, int n){
    vector<bool> is_prime(n + 1, true);
    if (n < 2) return;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            prime.push_back(i);
            for (int j = i * i; j <= n; j += i) is_prime[j] = false;
        }
    }
}
```



##### 快速幂

```cpp
#define ll long long
ll pow (ll x, ll n){
    ll ans = 1.0;
    while(n > 0){
        if(n & 1) ans *= x;
        n /= 2;
        x *= x;
    }
    return ans;
}
```



##### 费马小定理

`费马小定理`:  $p$为质数， $a$为任意自然数，则$a^p ≡ a\ (mod \ p)$

##### 逆元

$ a* x ≡ 1 (mod \ p)$   

中文描述: $a$乘一个数$x$并模$p$等于$1$

如果要求结果$mod$一个大质数，若原本的结果中有除法，比如除以$a$,那就可以乘以$a$的逆元来替代



###### 扩展欧几里得求逆元：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

void exgcd(ll a,ll b,ll& d,ll& x,ll& y) {
    if(!b) { d = a; x = 1; y = 0; }
    else{ exgcd(b, a%b, d, y, x); y -= x*(a/b); }
}

ll inv(ll a, ll p) {
    ll d, x, y;
    exgcd(a, p, d, x, y);
    return d == 1 ? (x + p) % p : -1;
}

int main()
{
    ll a,p;
    while(1)
    {
        scanf("%lld %lld",&a,&p);
        printf("%lld\n",inv(a,p));
    }
}
```

###### 费马小定理求逆元：

```cpp
ll power_mod(ll a, ll b, ll mod)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) 
            ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}
inv2 = power_mod(a, mod - 2, mod);
```



###### 欧拉定理求逆元：

```cpp
int eurler_phi(int n)
{
    int res = n;
    for(int i = 2; i * i <= n; i++){
        if(n % i == 0){
            res = res / i * (i - 1);
            while(n % i == 0) n /= i;
        }
    }
    if(n != 1) res = res / n * (n - 1);
    return res;
}
```





#### 约瑟夫环

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i != n + 1; ++i)
            f = (m + f) % i;
        return f;
    }
};
```

递归：

```cpp
int josephus(int n, int m) {  
    if(n == 1)  return 0;  
    else return (josephus(n - 1, m) + m) % n;  
}  
```



### 图论

#### 最小生成树

##### Kruskal

```cpp
int n,m;
struct edge{
    int x,y,v;
}e[maxm];
int cmp(edge a,edge b)
{
    return a.v<b.v;
}
int fa[maxn];
int find(int x)
{
    if(x==fa[x])
        return x;
    x=find(fa[x]);
    return fa[x];
}
int Kruskal()
{
    for(int i=1;i<=n;i++) fa[i]=i;
    sort(e+1,e+m+1,cmp);
    int cnt=0,ans=0;
    for(int i=1;i<=m;i++)
    {
        int fx=find(e[i].x),fy=find(e[i].y);
        if(fx==fy)  continue;
        fa[fx]=fy;
        ++cnt;
        ans+=e[i].v;
        if(cnt==n-1) break;
        
    }
    return ans;
}
```



##### Prim







#### 拓扑排序

```cpp
void topoSort(){
	for(int i = 0; i < N; i++) indeg[i] = 0;
	
	for(int u = 0; u < N; u++)
		for(int i = 0; i < G[u].size(); i++){
			int v = G[u][i];
			indeg[v]++;
		}

    queue<int> q;
	for(int u = 0; u < N; u++) if(indeg[u] == 0 && !V[u])  q.push(u);

	while(!q.empty() ){
		int u = q.front(); q.pop();
        V[u] = true;
		out.push_back(u);
		for(int i = 0; i < G[u].size(); i++){
			int v = G[u][i];
			indeg[v]--;
			if(indeg[v] == 0 && !V[v]){
				V[v] = true;
				q.push(v);
			}
		}
	}
}
```

#### 最短路

##### Floyd

##### Dijkstra

```cpp
int n,m,s,dis[maxn];
bool vis[maxn];

priority_queue<pa,vector<pa>,greater<pa> > q;

struct edge{
    int val,to;
};
vector<edge> e[maxn];

void dijkstra(){ //dis[i] 表示从起点到i的最短距离 
    for(int i=1;i<=n;i++) dis[i]=1000000001;
    dis[s]=0;
    q.push(make_pair(0, s));
    while(!q.empty()) {
        int x=q.top().second;
        q.pop();
        if(vis[x]) continue;
        vis[x]=1;
        for(int i=0;i<e[x].size();i++) {
            int y=e[x][i].to;
            if(dis[x]+e[x][i].val<dis[y]) {
                dis[y]=dis[x]+e[x][i].val;
                q.push(make_pair(dis[y], y));
            }
        }
    }
}

```



##### SPFA

```cpp
int n,m,s,dis[maxn];
bool vis[maxn];

struct edge{
    int val,to;
};
vector<edge> e[maxn];

queue<int> q;

void SPFA(){
    for(int i=1;i<=n;i++) dis[i]=1000000001;
    dis[s]=0;
    q.push(s);
    vis[s]=1;
    while(!q.empty()) {
        int x=q.front();
        q.pop();
        for(int i=0;i<e[x].size();i++) {
            int y=e[x][i].to;
            if(dis[x]+e[x][i].val<dis[y]) {
                dis[y]=dis[x]+e[x][i].val;
                if(!vis[y]) {
                    q.push(y);
                    vis[y]=1;
                }
            }
        }
        vis[x]=0;
    }
}
```



#### 缩点

##### 	tarjan

```cpp
栈：当前dfs路径上的点
low[x]:x能到达的点中最小的dfn


dfs(x,t)
    将x入栈 
    dfn[x]=t
    low[x]=t
    for(x,y)
        if(!vis[y]) 
            dfs(y,t+1),low[x]=min(low[x],low[y]);
        else
            if(y在栈中（在路径上）)
                low[x]=min(low[x],low[y])
    if(low[x]=dfn[x])
        将栈出到x 
```



#### 网络流

##### 	最大流 / 最小割

##### 

#### 连通分量

#### 二分图



### 字符串

>    处理空格 用`stringstream`.

#### 回文串



#### 字典树

模板：

```cpp
class Trie {
private:
    bool isWord = false;
    Trie* next[26] = {nullptr};
public:
    /** Initialize your data structure here. */
    Trie() {

    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) root->next[c-'a'] = new Trie();
            root = root->next[c-'a'];
        }
        root->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return root->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* root = this;
        for(auto c : prefix){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return true;
    }
};
```



#### KMP

```cpp
void getNext(string s, vector<int> &next){
    int i=0, j=-1;
    next[0] = -1;
    while(i < s.size()){
        if(j == -1 || s[i] == s[j]){
            i++; j++;
            next[i] = j;
        }
        else j = next[j];
    }
}
int kmp(string s, string pattern){
    int i = 0, j = 0;
    vector<int> next(pattern.size());
    getNext(pattern, next);
    
    while(i < s.size() && j < (int)pattern.size()){
        if(j == -1 || s[i] == pattern[j]){
            i++; j++;
        }
        else j = next[j];
    }
    //匹配完成
    if(j >= pattern.size()) return i-j;
    else return -1;
}
```

DP:

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



#### Manacher

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size < 2) {
            return s;
        }

        // 得到预处理字符串
        string str = "#";
        for (int i = 0; i < s.size(); ++i) {
            str += s[i];
            str += "#";
        }
        // 新字符串的长度
        int strSize = 2 * size + 1;
        // 数组 p 记录了扫描过的回文子串的信息
        vector<int> p(strSize, 0);

        // 双指针，它们是一一对应的，须同时更新
        int maxRight = 0;
        int center = 0;

        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度
        int maxLen = 1;
        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新
        int start = 0;

        for (int i = 0; i < strSize; ++i) {
            if (i < maxRight) {
                int mirror = (2 * center) - i;
                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解
                p[i] = min(maxRight - i, p[mirror]);
            }

            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中
            int left = i - (1 + p[i]);
            int right = i + (1 + p[i]);

            // left >= 0 && right < sLen 保证不越界
            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次
            while (left >= 0 && right < strSize && str[left] == str[right]) {
                p[i]++;
                left--;
                right++;

            }

            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者
            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了
            if (i + p[i] > maxRight) {
                // maxRight 和 center 需要同时更新
                maxRight = i + p[i];
                center = i;
            }
            if (p[i] > maxLen) {
                // 记录最长回文子串的长度和相应它在原始字符串中的起点
                maxLen = p[i];
                start = (i - maxLen) / 2;
            }
        }
        return s.substr(start, maxLen);
    }
};
```



## 数据结构

### 图



### 堆



### 树

#### Morris遍历

##### 模板：

```cpp
TreeNode *getSuccessor(TreeNode *root){
        TreeNode* node = root->left;
        while(node->right && node->right!=root) node = node->right;
        return node;
    }
void morrisTraversal(TreeNode *root){
    TreeNode* node = root;
    while(node){
        if(node->left==nullptr){
            helper(); //其他处理
            node = node -> right;
        }
        else{
            TreeNode* succ = getSuccessor(node);
            if(succ->right == nullptr){
                succ->right = node;
                node = node->left;
            }
            else{
                succ->right = nullptr;
                helper();
                node = node->right;
            }
        }
    }
}
```



##### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

​    给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

 

**例如：**

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    TreeNode* getSuccessor(TreeNode* node){
        TreeNode* succ = node->right;
        while(succ->left!=NULL && succ->left!=node) succ = succ->left;
        return succ;
    }
    TreeNode* convertBST(TreeNode* root) {
        TreeNode* node = root;

        while(node != NULL){
            if(node->right==NULL){
                sum += node->val; // 处理和
                node->val = sum;
                node=node->left;
            }
            else{
                TreeNode* succ = getSuccessor(node);
                if(succ->left == NULL){
                    succ->left = node;
                    node = node->right;
                }else{
                    succ->left = NULL;
                    sum += node->val;
                    node->val = sum;
                    node=node->left;
                }
            }
        }
        return root;
    }
};
```



##### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

-   结点左子树中所含结点的值小于等于当前结点的值
-   结点右子树中所含结点的值大于等于当前结点的值
-   左子树和右子树都是二叉搜索树

例如：
给定 BST `[1,null,2,2]`,

```
   1
    \
     2
    /
   2
```

`返回[2]`.



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    int base, cnt=0, maxCnt=0;

    /*
    * 处理函数
    * 中序遍历后相等的数一定相邻
    */
    void helper(int x){
        // base 指当前保存的‘众数’
        if(x == base) cnt++;
        else{
            // 换‘众数’
            cnt = 1;
            base = x;
        }

        if(cnt == maxCnt) ans.emplace_back(x);
        if(cnt > maxCnt){
            maxCnt = cnt;
            ans = vector<int>{base};
        }
    }

    TreeNode *getSuccessor(TreeNode *root){
        TreeNode* node = root->left;
        while(node->right && node->right!=root) node = node->right;
        return node;
    }
    void morrisTraversal(TreeNode *root){
        TreeNode* node = root;
        while(node){
            //cout << node << endl;
            if(node->left==nullptr){
                helper(node->val);
                node = node -> right;
            }
            else{
                TreeNode* succ = getSuccessor(node);
                if(succ->right == nullptr){
                    succ->right = node;
                    node = node->left;
                }
                else{
                    succ->right = nullptr;
                    helper(node->val);
                    node = node->right;
                }
            }
        }
    }  
    vector<int> findMode(TreeNode* root) {
        morrisTraversal(root);
        return ans;
    }
};
```





##### 后续遍历



##### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定一个二叉树，返回它的 后序 遍历。

示例:

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3
输出: [3,2,1]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void helper(vector<int> &ans, TreeNode* node){
        vector<int> tmp;
        while(node){
            tmp.emplace_back(node->val);
            node = node->right;
        }
        reverse(tmp.begin(), tmp.end());

        for(auto x:tmp){
            ans.emplace_back(x);
        }
    }
    TreeNode *getSuccessor(TreeNode *root){
        TreeNode* node = root->left;
        while(node->right && node->right!=root) node = node->right;
        return node;
    }
    vector<int> morrisTraversal(TreeNode *root){
        TreeNode* node = root;
        vector<int> ans;
        while(node){
            // if(node->left==nullptr){
            //     helper(); //其他处理
            //     node = node -> right;
            // }
            if(node->left != nullptr){
                TreeNode* succ = getSuccessor(node);
                if(succ->right == nullptr){
                    succ->right = node;
                    node = node->left;
                    continue;
                }
                else{
                    succ->right = nullptr;
                    helper(ans, node->left);
                }
            }
            node = node->right;
        }
        helper(ans, root);
        return ans;
    }
    vector<int> postorderTraversal(TreeNode* root) {
        return morrisTraversal(root);
    }
};
```



#### 构造二叉树

##### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

例：

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

二叉树：

    	3
       / \
      9  20
        /  \
       15   7

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> pre, in;
    map<int, int> pos;
    TreeNode* build(int pre_l, int pre_r, int in_l, int in_r){
        if(pre_l > pre_r) return nullptr;
      
        int pre_val = pre[pre_l];
        int p = pos[pre_val];
        
        int num = p-in_l;

        TreeNode* root = new TreeNode(pre_val); 
        
        root-> left = build(pre_l+1, pre_l+num, in_l, p-1);
        root -> right = build(pre_l+num+1, pre_r, p+1, in_r);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        pre = preorder; in = inorder;
        for(int i = 0; i < inorder.size(); i++) pos[inorder[i]] = i;
        return build(0, preorder.size()-1, 0, inorder.size()-1);
    }
};
```



##### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

例：

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

二叉树：

        3
       / \
      9  20
        /  \
       15   7

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> in, post;
    map<int, int> pos;
    int rt;
    TreeNode* build(int l, int r){
        if(l > r) return nullptr;
      
        int post_val = post[rt];
        int p = pos[post_val];
        
        TreeNode* root = new TreeNode(post_val); 
        rt--;
        root -> right = build(p+1, r);
        root-> left = build(l, p-1);
        
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        in = inorder; post = postorder;
        rt = inorder.size()-1;
        for(int i = 0; i < inorder.size(); i++) pos[inorder[i]] = i;
        return build(0, rt);
    }
};
```



### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

返回与给定的前序和后序遍历匹配的`任何二叉树`。

例：

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

二叉树：

          1
         /  \
        2    3
       / \  / \
      4   5 6  7

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        int N = pre.length;
        if (N == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        if (N == 1) return root;

        int L = 0;
        for (int i = 0; i < N; ++i)
            if (post[i] == pre[1])
                L = i+1;

        root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, L+1),
                                         Arrays.copyOfRange(post, 0, L));
        root.right = constructFromPrePost(Arrays.copyOfRange(pre, L+1, N),
                                          Arrays.copyOfRange(post, L, N-1));
        return root;
    }
}
```





### 栈

单调栈

### 队列

单调队列

### 字符串



### 数组



### 线段树

