# 蓝桥杯复习提纲

## 算法

### 枚举



### 排序



### 搜索



### 回溯



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```cpp
do{
    
} while(next_permutation(nums.begin(), nums.end()))
```



```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        do {
            result.emplace_back(nums);
        } while (next_permutation(nums.begin(), nums.end()));
        return result;
    }
};
```



#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```cpp
// 二维
class Solution {
public:
    vector<vector<string> > ans;
    int n;
    bool check(vector<string> &queen, int row, int col){
        for(int i=0; i<row; i++){
            if(queen[i][col] == 'Q') return false;
        }
        for(int i=row-1, j=col-1; i>=0 && j>=0; j--, i--){
            if(queen[i][j]=='Q') return false;
        }
        for(int i=row-1, j=col+1; i>=0 && j<n; j++, i--){
            if(queen[i][j] == 'Q') return false;
        }
        return true;
    }
    void helper(vector<string> &queen, int row){
        if(row == n){
            ans.emplace_back(queen);
            return;
        }
        for(int i=0; i<n; i++){
            if(check(queen, row, i)){
                queen[row][i] = 'Q';
                helper(queen, row+1);
                queen[row][i] = '.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        vector<string> queen(n, string(n, '.'));
        helper(queen, 0);
        return ans;
    }
};
```



```cpp
// 一维

class Solution {
public:
    vector<vector<string> > ans;
    int n;
    bool check(vector<int> &queen, int row, int col){
        for(int i=0; i<row; i++){
            if(queen[i]==col || abs(queen[i]-col) == abs(i-row)) return false;
        }
        return true;
    }
    void helper(vector<int> &queen, int row){
        if(row == n){
            vector<string> tmp(n, string(n, '.'));
            for(int i=0; i<n; i++){
                tmp[i][queen[i]] = 'Q';
            }
            ans.emplace_back(tmp);
            return;
        }
        for(int i=0; i<n; i++){
            if(check(queen, row, i)){
                queen[row]=i;
                helper(queen, row+1);
                queen[row]=-1;
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        vector<int> queen(n, -1);
        helper(queen, 0);
        return ans;
    }
};

```



#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

```cpp
bitset:
状态压缩
1. 使用 bitset<9> 来压缩存储每一行、每一列、每一个 3x3 宫格中 1-9 是否出现
2. 这样每一个格子就可以计算出所有不能填的数字，然后得到所有能填的数字 getPossibleStatus()
3. 填入数字和回溯时，只需要更新存储信息
4. 每个格子在使用时，会根据存储信息重新计算能填的数字

回溯
1. 每次都使用 getNext() 选择能填的数字最少的格子开始填，这样填错的概率最小，回溯次数也会变少
2. 使用 fillNum() 在填入和回溯时负责更新存储信息
3. 一旦全部填写成功，一路返回 true ，结束递归
```

![图片.png](https://pic.leetcode-cn.com/1fb1c64cfddb5c66b61bd769224724a05027172d6486feb19b3a16d9473372ee-%E5%9B%BE%E7%89%87.png)

```cpp
class Solution {
public:
    vector<bitset<9> > rows, cols;
    vector<vector<bitset<9> > > cells;

    bitset<9> getPosibleStatus(int x, int y){
        return ~(rows[x] | cols[y] | cells[x/3][y/3]);
    }

    vector<int> getNext(vector<vector<char> > &board){
        
        vector<int> ans;
        int minCnt = 0x3f;
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[i].size(); j++){
                if(board[i][j] != '.') continue;
                auto cur = getPosibleStatus(i, j);
                int c = cur.count();
                if(c < minCnt){
                    minCnt = c;
                    ans = {i, j};
                }
            }
        }

        return ans;
    }
    void fillNum(int x, int y, int n, bool flag){
        rows[x][n] = flag ? 1 : 0;
        cols[y][n] = flag ? 1 : 0;
        cells[x/3][y/3][n] = flag ? 1 : 0;
    }

    bool helper(vector<vector<char> > &board, int cnt){
        if(cnt == 0) return true;

        auto next = getNext(board);
        auto bits = getPosibleStatus(next[0], next[1]);

        for(int i=0; i<bits.size(); i++){
            if(!bits.test(i)) continue;
            int x = next[0], y = next[1];
            fillNum(x, y, i, true);
            board[x][y] = i+'1';
            if(helper(board, cnt-1)) return true;
            board[x][y] = '.';
            fillNum(x, y, i, false);
        }

        return false;
    }
    void solveSudoku(vector<vector<char>>& board) {
        rows = vector<bitset<9> > (9, bitset<9>());
        cols = vector<bitset<9> > (9, bitset<9>());
        cells = vector<vector<bitset<9> > > (3, vector<bitset<9> >(3, bitset<9>()));


        int cnt = 0;
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[i].size(); j++){
                cnt += (board[i][j] == '.');
                if(board[i][j] == '.') continue;
            
                int n=board[i][j] - '1';
                rows[i] |= (1<<n);
                cols[j] |= (1<<n);
                cells[i/3][j/3] |= (1<<n);
            }
        }

        helper(board, cnt);
    }
};
```

#### [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

```cpp
class Solution {
public:
    int m, n;
    int dist[8][2] = {1, 0, -1, 0, 0, 1, 0, -1, 1, -1, -1, 1, 1, 1, -1, -1};
    void bfs(vector<vector<char>>& board, int sr, int sc){
        queue<pair<int, int> > q;
        bool vis[55][55];
        memset(vis, false, sizeof vis);
        vis[sr][sc] = true;
        q.push({sr, sc});
        while(!q.empty()){
            auto u = q.front(); q.pop();
            int x=u.first, y=u.second;
            int cnt=0;
            for(int i=0; i<8; i++){
                int x1=x+dist[i][0];
                int y1=y+dist[i][1];
                if(x1<0||y1<0||x1>=m||y1>=n) continue;
                cnt += board[x1][y1] == 'M';
            }

            if(cnt){
                board[x][y] = cnt+'0';
            }else{                
                board[x][y] = 'B';

                for(int i=0; i<8; i++){
                    int x1=x+dist[i][0];
                    int y1=y+dist[i][1];
                    if(x1<0||y1<0||x1>=m||y1>=n || vis[x1][y1] || board[x1][y1]!='E') continue;
                    q.push({x1, y1});
                    vis[x1][y1] = true;
                }
            }
        }
    }
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        m=board.size(); n=board[0].size();
        if(board[click[0]][click[1]] == 'M'){
            board[click[0]][click[1]] = 'X';
        }else{
            bfs(board, click[0], click[1]);
        }
        return board;
    }
};
```



#### [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)

```cpp
class Solution {
public: 
    static constexpr int TARGET = 24;
    static constexpr double EPSILON = 1e-6;
    static constexpr int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;
    bool judgePoint24(vector<int>& nums) {
        vector<double> ans;
        for(int num : nums) ans.emplace_back(static_cast<double>(num));
        return helper(ans);
    }

    bool helper(vector<double> nums){
        if(nums.size() == 0) return false;
        if(nums.size() == 1) return fabs(TARGET-nums[0])<=EPSILON;
        
        int sz = nums.size();

        for(int i=0; i<sz; i++){
            for(int j=0; j<sz; j++){
                if(i==j) continue;
                vector<double> l;
                for(int k=0; k<sz; k++){
                    if(k==j || k==i) continue;
                    l.emplace_back(nums[k]);
                }

                for (int k = 0; k < 4; k++) {
                    /* 
                    加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，
                    则对于选出的 22 个数字不需要考虑不同的顺序，
                    在遇到第二种顺序时可以不进行运算，直接跳过。
                    */
                    if (k < 2 && i > j)  continue; 
                    if (k == ADD) l.emplace_back(nums[i] + nums[j]);
                    else if (k == MULTIPLY) l.emplace_back(nums[i] * nums[j]);
                    else if (k == SUBTRACT) l.emplace_back(nums[i] - nums[j]);
                    else if (k == DIVIDE) {
                        // 除法为零
                        if (fabs(nums[j]) < EPSILON) continue;
                        l.emplace_back(nums[i] / nums[j]);
                    }
                    if (helper(l)) return true; 
                    l.pop_back();
                }
            }
        }
        return false;
    }
};
```

#### [488. 祖玛游戏](https://leetcode-cn.com/problems/zuma-game/)

```cpp
1. 如果后面的球与前面的球颜色不一样，在这里尝试插入一个后面颜色的球
2. 如果相邻的两个球颜色相同，考虑在中间插入一个其他颜色的球，将他们分割
```

代码：

```cpp
class Solution {
public:
    int findMinStep(string board, string hand) {
        cnt = hand.size();
        for (auto c : hand) {
            h[c - 'A']++;
        }

        dfs(board, 0);
        return ans == INT_MAX ? -1 : ans;
    }

    void dfs(string board, int step) {
        shoot(board);

        if (board.empty()) {
            ans = min(ans, step);
        }
        if (step == cnt) return;
        if (step >= ans) return;

        set<pair<int, char>> ins;
        for (int i = 0; i < board.size(); i++) {
            int t = board[i] - 'A';
            if (i == 0 || board[i] != board[i - 1]) {
                if (h[t] != 0) {
                    ins.insert({ i, 'A' + t });
                }
            }
            if (i != 0 && board[i] == board[i - 1]) {
                for (int j = 0; j < h.size(); j++) {
                    if (j == t || h[j] == 0) continue;
                    ins.insert({ i, 'A' + j });
                }
            }
        }

        for (auto[i, c] : ins) {
            h[c - 'A']--;
            board.insert(i, 1, c);
            dfs(board, step + 1);
            board.erase(i, 1);
            h[c - 'A']++;
        }
    }

    void shoot(string& board) {
        for (int i = 0; i < (int)board.size() - 2; i++) {
            int j = i + 1;
            while (j < board.size() && board[i] == board[j]) j++;
            if (j - i < 3) {
                i = j - 1;
                continue;
            }
            board.erase(i, j - i);
            shoot(board);
            break;
        }
    }

private:
    int ans = INT_MAX;
    int cnt = 0;
    vector<int> h = vector<int>(26, 0);
};

```





### 计数

#### 进制转换

```cpp
void dec2bin(int num){
    stack<int> bin;
    while(num!=0){
        bin.push(num % 2);
        num /= 2;
    }
    return bin;
}
```





### 贪心

#### 区间调度

##### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20201004200801104](F:\c++\Game\LanQiao\复习.assets\image-20201004200801104.png)

代码：

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.size() == 0) return 0;
        
        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) -> bool {
            return a[1] < b[1];
        });
        
        int end = intervals[0][1];
        int res = -1;
        for(auto G:intervals){
            if(G[0] < end) res++;
            else end = G[1];
        }
        return res;
    }
};
```



### 动态规划



![image-20201002105136332](F:\c++\Game\LanQiao\复习.assets\image-20201002105136332.png)

#### 背包系列

###### 思路：

```cpp
for (int i = 1; i <= n; i++) {
    // 01背包：逆序遍历
	// for (int j = m; j >= w[i]; j--) {
	// 完全背包：正向遍历
	for (int j = w[i]; j <= m; j++) {
		maxValue[j] = max(maxValue[j], maxValue[j - w[i]] + v[i]);
    }
}
```



##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

01背包(内外层循环的顺序)

```cpp
class Solution {
public:
    int subsets(vector<int>& nums, int target){
        vector<int> dp(target+10, 0);
        dp[0] = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = target; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] += dp[j-nums[i]];
                else dp[j] = dp[j];
            }
        }
        return dp[target];
    }
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for(int num : nums) sum += num;
        // 2 * A = S + sum(nums) A是正数集合 B是负数集合
        if(sum < S || (sum+S)%2 == 1) return 0;
        return subsets(nums, (sum+S)/2);
    }
};
```

##### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int &num : nums) sum += num;
        if(sum % 2 == 1) return false;
        sum /= 2;
        vector<bool> dp(sum+1, 0);
        dp[0] = true;
        for(int i = 0; i < nums.size(); i++){
            for(int j = sum; j >= 0; j--){
                if(j - nums[i] >= 0) dp[j] = dp[j] || dp[j-nums[]];
            }
        }
        return dp[sum];
    }
};
```



##### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+10, 0x3f3f3f3f);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(auto &coin : coins)
                if(i - coin >= 0) dp[i] = min(dp[i], dp[i-coin]+1);
        }
        return dp[amount] == 0x3f3f3f3f ? -1 : dp[amount];
    }
};
```





#### 股票系列：

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

思路：

```cpp
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```

状态转移方程：

```cpp
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

代码：

```cpp
class Solution {
public:
    int maxProfit_inf(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<vector<int> > dp(prices.size() + 2, vector<int>(2, 0));
        dp[0][0] = 0; dp[0][1] = -prices[0];
        for(int i = 1; i <= prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i-1]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1]);
        }
        return dp[prices.size()][0];
    }

    int maxProfit(int K, vector<int>& prices) {
        if(!prices.size()) return 0;
        if(K >= prices.size()/2) return maxProfit_inf(prices);

        vector<vector<vector<int> > > dp(prices.size() + 2, vector<vector<int> >(K+1, vector<int>(2, 0)));
        for(int i = 0; i <= K; i++){
            dp[0][i][0] = 0; dp[0][i][1] = -0x3f3f3f3f;
        }

        for(int i = 1; i <= prices.size(); i++){
            for(int k = 1; k <= K; k++){
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i-1]);
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1]);
            }
        }
        return dp[prices.size()][K][0];
    }
};
```

#### 打家劫舍系列

##### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

思路：

```cpp
dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
           选上一个， 或者选当前和上上一个
```



代码：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size()+2, 0);
        for(int i = nums.size()-1; i>=0; i--){
            dp[i] = max(dp[i+1], dp[i+2]+nums[i]);
        }
        return dp[0];
    }
};
```



#### 字符串DP

##### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

KMP / DP

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



##### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```cpp
int dp[1000][1000];
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i <= m; i++) dp[i][0] = i;
        for(int j = 0; j <= n; j++) dp[0][j] = j;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
            }
        }
        return dp[m][n];
    }
};
```



##### [651.四键键盘](https://leetcode-cn.com/problems/4-keys-keyboard)

![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6413dee2c83f74205c7f2d5eb0784232429512de.png?alt=media)



![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F43c7985b4e7201e0ffc8ff5c580883e60e98ed3b.jpg?alt=media)

代码：

```java
public int maxA(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        // 按 A 键
        dp[i] = dp[i - 1] + 1;
        for (int j = 2; j < i; j++) {
            // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }
    // N 次按键之后最多有几个 A？
    return dp[N];
}
```



##### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > dp(s.size(), vector<bool>(s.size(), false));

        for(int i = 0; i < s.size(); i++) dp[i][i] = true;

        int begin = 0, maxSize = 1;
        for(int j = 1; j < s.size(); j++){
            for(int i = 0; i < j; i++){
                if(s[i] == s[j]){
                    if(j - i < 3) dp[i][j] = true;
                    else dp[i][j] = dp[i+1][j-1];
                    
                }
                else dp[i][j] = false;

                if(dp[i][j] && maxSize < j-i+1){
                    maxSize = j-i+1;
                    begin = i;
                }
            }
        }

        return s.substr(begin, maxSize);
    }
};
```



##### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

代码：

```cpp
int dp[1010];
class Solution {
public:
    // int longestPalindromeSubseq(string s) {
    //     vector<vector<int> > dp(s.size()+10, vector<int>(s.size()+10, 0));
    //     for(int i = 0; i < s.size(); i++) dp[i][i] = 1;

    //     for(int i = s.size()-2; i >= 0; i--){
    //         for(int j = i+1; j < s.size(); j++){
    //             if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2;
    //             else dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
    //         }
    //     }
    //     return dp[0][s.size()-1];
    // }
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        for(int i = 0; i < n; i++) dp[i] = 1;

        for(int i = n-2; i >= 0; i--){
            int pre = 0;
            for(int j = i+1; j < n; j++){
                int t = dp[j];
                if(s[i] == s[j]) dp[j] = pre + 2;
                else dp[j] = max(dp[j-1], dp[j]);
                pre = t;
            }
        }
        return dp[s.size()-1];
    }
};
```



#### 博弈

##### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int> > dp(n+1, vector<int>(n+1, 0));
        // dp[i][j] 定义：区间 piles[i..j] 内先手可以获得的净胜分
        for(int i = 0; i < n; i++) dp[i][i] = piles[i];
        for(int i = n-2; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]);
            }
        }
        return dp[0][n-1] > 0;
    }
};
```



#### 区间DP

##### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> points(n+2);
        for(int i = 1; i <= n; i++) points[i] = nums[i-1];
        points[0] = points[n+1] = 1;
        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));

        for(int i = n; i >= 0; i--){
            for(int j = i+1; j <= n + 1; j++){
                for(int k = i+1; k < j; k++){
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i]*points[k]*points[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```



#### 树状DP

##### [834. 树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)

```cpp
class Solution {
public:
    vector<vector<int> > G;
    vector<int> ans;
    vector<int> dp, sz;
    void dfs(int u, int fa){
        dp[u] = 0;
        sz[u] = 1;
        for(auto v : G[u]){
            if(v == fa) continue;
            dfs(v, u);
            dp[u] += dp[v] + sz[v];
            sz[u] += sz[v];
        }
    }

    void dfs2(int u, int fa){
        ans[u] = dp[u];
        for(auto v : G[u]){
            if(v == fa) continue;
            int pu = dp[u], pv = dp[v];
            int su = sz[u], sv = sz[v];

            dp[u] -= dp[v] + sz[v];
            sz[u] -= sz[v];

            dp[v] += dp[u] + sz[u];
            sz[v] += sz[u];

            dfs2(v, u);

            dp[u] = pu; dp[v] = pv;
            sz[u] = su; sz[v] = sv;
        }
    }
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {
        G = vector<vector<int> > (N);
        ans = vector<int>(N);
        dp = vector<int>(N, 0);
        sz = vector<int>(N, 0);
        for(auto e : edges){
            G[e[0]].emplace_back(e[1]);
            G[e[1]].emplace_back(e[0]);
        }
        dfs(0, -1);
        // for(auto v : dp) cout << v << " ";
        dfs2(0, -1);
        return ans;
    }
};
```





#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), -0x3f3f);
        int res = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(nums[i], nums[i] + dp[i-1]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```



#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for(int i = 0; i < nums.size(); i++){
            for(int j = i-1; j>=0; j--){
                if(nums[j] < nums[i]) dp[i] = max(dp[i], dp[j]+1);
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```cpp
int dp[1010];
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();

        //vector<vector<int> > dp(m+1, vector<int>(n+1, 0));
        for(int i = 0; i <= n; i++) dp[i] = 0;

        // for(int i = 1; i <= m; i++){
        //     for(int j = 1; j <= n; j++){
        //         if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
        //         else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        //     }
        // }
        
        for(int i = 1; i <= m; i++){
            int pre = 0;
            for(int j = 1; j <= n; j++){
                int t = dp[j];
                if(text1[i-1] == text2[j-1]) dp[j] = pre + 1;
                else dp[j] = max(dp[j], dp[j-1]);
                pre = t;
            }
        }
        return dp[n];
    }
};
```





### 数论

#### 博弈

​	Nim

#### 排列组合

#### 数论

​	LCM / GCD
​	BigNum
​	扩展欧几里得
​	素数筛
​	快速幂
​	费马小定理

#### 约瑟夫环

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i != n + 1; ++i)
            f = (m + f) % i;
        return f;
    }
};
```

递归：

```cpp
int josephus(int n, int m) {  
    if(n == 1)  return 0;  
    else return (josephus(n - 1, m) + m) % n;  
}  
```



### 图论



### 字符串

>    处理空格 用`stringstream`.

#### 回文串



#### 字典树

模板：

```cpp
class Trie {
private:
    bool isWord = false;
    Trie* next[26] = {nullptr};
public:
    /** Initialize your data structure here. */
    Trie() {

    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) root->next[c-'a'] = new Trie();
            root = root->next[c-'a'];
        }
        root->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* root = this;
        for(auto c : word){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return root->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* root = this;
        for(auto c : prefix){
            if(root->next[c-'a'] == nullptr) return false;
            root = root->next[c-'a'];
        }
        return true;
    }
};
```



#### KMP

```cpp
void getNext(string s, vector<int> &next){
    int i=0, j=-1;
    next[0] = -1;
    while(i < s.size()){
        if(j == -1 || s[i] == s[j]){
            i++; j++;
            next[i] = j;
        }
        else j = next[j];
    }
}
int kmp(string s, string pattern){
    int i = 0, j = 0;
    vector<int> next(pattern.size());
    getNext(pattern, next);
    
    while(i < s.size() && j < (int)pattern.size()){
        if(j == -1 || s[i] == pattern[j]){
            i++; j++;
        }
        else j = next[j];
    }
    //匹配完成
    if(j >= pattern.size()) return i-j;
    else return -1;
}
```

DP:

```cpp
const int maxn = 1e5+10;
int dp[maxn][256];
class Solution {
public:
    void kmp(string pattern){
        int n = pattern.size();

        dp[0][pattern[0]] = 1;
        int X = 0;
        for(int i = 1; i < pattern.size(); i++){
            for(int j = 0; j < 256; j++)
                dp[i][j] = dp[X][j];
            dp[i][pattern[i]] = i + 1;
            X = dp[X][pattern[i]];
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) return 0;
        memset(dp, 0, sizeof dp);
        int j = 0;
        kmp(needle);
        for(int i = 0; i < haystack.size(); i++){
            auto c = haystack[i];
            j = dp[j][c];
            if(j == needle.size()) return i - needle.size() + 1;
        }

        return -1;
    }
};
```



#### Manacher

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size < 2) {
            return s;
        }

        // 得到预处理字符串
        string str = "#";
        for (int i = 0; i < s.size(); ++i) {
            str += s[i];
            str += "#";
        }
        // 新字符串的长度
        int strSize = 2 * size + 1;
        // 数组 p 记录了扫描过的回文子串的信息
        vector<int> p(strSize, 0);

        // 双指针，它们是一一对应的，须同时更新
        int maxRight = 0;
        int center = 0;

        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度
        int maxLen = 1;
        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新
        int start = 0;

        for (int i = 0; i < strSize; ++i) {
            if (i < maxRight) {
                int mirror = (2 * center) - i;
                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解
                p[i] = min(maxRight - i, p[mirror]);
            }

            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中
            int left = i - (1 + p[i]);
            int right = i + (1 + p[i]);

            // left >= 0 && right < sLen 保证不越界
            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次
            while (left >= 0 && right < strSize && str[left] == str[right]) {
                p[i]++;
                left--;
                right++;

            }

            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者
            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了
            if (i + p[i] > maxRight) {
                // maxRight 和 center 需要同时更新
                maxRight = i + p[i];
                center = i;
            }
            if (p[i] > maxLen) {
                // 记录最长回文子串的长度和相应它在原始字符串中的起点
                maxLen = p[i];
                start = (i - maxLen) / 2;
            }
        }
        return s.substr(start, maxLen);
    }
};
```



## 数据结构

### 图



### 堆



### 树

二叉树 Morris遍历  前序中序后续遍历

根据前序遍历和中序遍历。。。。。



### 栈



### 队列



### 字符串



### 数组



### 线段树

